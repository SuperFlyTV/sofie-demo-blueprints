"use strict";(globalThis.webpackChunkdocs=globalThis.webpackChunkdocs||[]).push([[329],{278(e,t,i){i.r(t),i.d(t,{assets:()=>c,contentTitle:()=>r,default:()=>h,frontMatter:()=>a,metadata:()=>n,toc:()=>l});const n=JSON.parse('{"id":"adlibs/tsr_actions","title":"TSR Actions","description":"Introduction to TSR Actions","source":"@site/docs/adlibs/tsr_actions.md","sourceDirName":"adlibs","slug":"/adlibs/tsr_actions","permalink":"/sofie-demo-blueprints/docs/adlibs/tsr_actions","draft":false,"unlisted":false,"editUrl":"https://github.com/SuperFlyTV/sofie-demo-blueprints/tree/docs/docusaurus/packages/docs/docs/docs/adlibs/tsr_actions.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Trigger modes and dynamic data in AdLib Actions","permalink":"/sofie-demo-blueprints/docs/adlibs/adlib_actions/trigger_modes_and_dynamic_data"},"next":{"title":"Global Configurations","permalink":"/sofie-demo-blueprints/docs/global_configurations"}}');var o=i(1085),s=i(1184);const a={},r="TSR Actions",c={},l=[{value:"Introduction to TSR Actions",id:"introduction-to-tsr-actions",level:2},{value:"Why do they exist?",id:"why-do-they-exist",level:3},{value:"A few words of caution",id:"a-few-words-of-caution",level:3},{value:"How do define a TSR action",id:"how-do-define-a-tsr-action",level:2},{value:"How to execute a TSR action from an Adlib Action",id:"how-to-execute-a-tsr-action-from-an-adlib-action",level:2}];function d(e){const t={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",...(0,s.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(t.header,{children:(0,o.jsx)(t.h1,{id:"tsr-actions",children:"TSR Actions"})}),"\n",(0,o.jsx)(t.h2,{id:"introduction-to-tsr-actions",children:"Introduction to TSR Actions"}),"\n",(0,o.jsx)(t.p,{children:"A TSR Action is a method which is executed inside of a TSR integration. The method can be called upon from Sofie, and subsequently Blueprints Adlib Actions."}),"\n",(0,o.jsx)(t.h3,{id:"why-do-they-exist",children:"Why do they exist?"}),"\n",(0,o.jsxs)(t.p,{children:['The main way to control devices (through TSR integrations) in Sofie is via the Timeline. By defining a time-based "State" in blueprints, the TSR can diff the target State compared to the current State at the time of playout, and generate commands to send. This is powerful since it allows Sofie (and blueprints) to not have to take into account the "current state" of the controlled device, and instead focus on the desired state at the time of playout.\nIt also decouples the TSR device from Sofie/Blueprints on a "time-sensitiveness" level, since it allows Sofie to ',(0,o.jsx)(t.em,{children:"not"})," have to be as time-sensitive as the TSR device and increases the likelihood of commands being sent at the correct time."]}),"\n",(0,o.jsx)(t.p,{children:'For certain operations though, the time sensitivity is not important, and there is no state to be diffed. Some example operations can be "Restart a device", "Clear all channels", "Send a custom HTTP request" or "Retrieve some data". It is for these operations that TSR Actions exist. TSR Actions are often being used in these ways during onRundownActivate and onRundownDeActivate, to reset and prepare the system for a show or to perform some cleanup.'}),"\n",(0,o.jsx)(t.h3,{id:"a-few-words-of-caution",children:"A few words of caution"}),"\n",(0,o.jsx)(t.p,{children:'It can be tempting to design a TSR device to ONLY expose TSR Actions, and not use the Timeline at all. This is (often) not recommended, as if goes agains one of the core design philosophies of Sofie - the "state-based approach". In general, if an "action" can be considered to modify a trackable state of a device (for example: the "play" and "stop" actions modifies the playing status of a video player), it should be defined as a state in TSR and controlled via the Timeline, and not be a TSR Action.'}),"\n",(0,o.jsx)(t.h2,{id:"how-do-define-a-tsr-action",children:"How do define a TSR action"}),"\n",(0,o.jsx)(t.p,{children:(0,o.jsx)(t.a,{href:"https://github.com/Sofie-Automation/sofie-timeline-state-resolver/tree/main/packages/timeline-state-resolver/src/integrations/abstract",children:"https://github.com/Sofie-Automation/sofie-timeline-state-resolver/tree/main/packages/timeline-state-resolver/src/integrations/abstract"})}),"\n",(0,o.jsxs)(t.ol,{children:["\n",(0,o.jsxs)(t.li,{children:["Define the method to be executed at the TSR integration.\nref: ",(0,o.jsx)(t.a,{href:"https://github.com/Sofie-Automation/sofie-timeline-state-resolver/blob/release52/packages/timeline-state-resolver/src/integrations/abstract/index.ts#L31",children:"https://github.com/Sofie-Automation/sofie-timeline-state-resolver/blob/release52/packages/timeline-state-resolver/src/integrations/abstract/index.ts#L31"})]}),"\n",(0,o.jsxs)(t.li,{children:["Define the action in the TSR integration schema\nref: ",(0,o.jsx)(t.a,{href:"https://github.com/Sofie-Automation/sofie-timeline-state-resolver/blob/release52/packages/timeline-state-resolver/src/integrations/abstract/%24schemas/actions.json#L5",children:"https://github.com/Sofie-Automation/sofie-timeline-state-resolver/blob/release52/packages/timeline-state-resolver/src/integrations/abstract/%24schemas/actions.json#L5"})]}),"\n",(0,o.jsxs)(t.li,{children:["Run ",(0,o.jsx)(t.code,{children:"yarn generate-schema-types"})," to generate the TypeScript types for the action schema in timeline-state-resolver-types folder"]}),"\n"]}),"\n",(0,o.jsx)(t.h2,{id:"how-to-execute-a-tsr-action-from-an-adlib-action",children:"How to execute a TSR action from an Adlib Action"}),"\n",(0,o.jsx)(t.p,{children:"Here is an example for how to execute a TSR Action from within a Blueprint Adlib Action:"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-typescript",children:"import { TSR, IRundownActivationContext } from '@sofie-automation/blueprints-integration'\n\nexport async function onMyAdlibAction(context: IActionExecutionContext): Promise<void> {\n\t// Get a list of the available TSR devices:\n\tconst devices = await context.listPlayoutDevices()\n\n\t// Pick a certain device (or just hardcode the deviceId if you know it):\n\tconst myDevice = devices.find((device) => device.deviceType === TSR.DeviceType.CASPARCG)\n\n\tif (myDevice) {\n\t\t// execute the TSR Action\n\t\tconst result = await context.executeTSRAction(myDevice.deviceId, TSR.CasparCGActions.ClearAllChannels, {\n\t\t\t// payload\n\t\t})\n\n\t\tif (result.result === TSR.ActionExecutionResultCode.Ok) {\n\t\t\tresult.resultData // This is the result data, if any\n\t\t} else if (result.result === TSR.ActionExecutionResultCode.Error) {\n\t\t\t// handle error\n\t\t\tresult.response\n\t\t\tresult.resultData // This is the result data, if any\n\t\t} else if (result.result === TSR.ActionExecutionResultCode.IgnoredNotRelevant) {\n\t\t\t// IgnoredNotRelevant can be returned from the TSR Action if the action was not relevant and therefore ignored\n\t\t}\n\t}\n}\n"})})]})}function h(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}},1184(e,t,i){i.d(t,{R:()=>a,x:()=>r});var n=i(4041);const o={},s=n.createContext(o);function a(e){const t=n.useContext(s);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:a(e.components),n.createElement(s.Provider,{value:t},e.children)}}}]);